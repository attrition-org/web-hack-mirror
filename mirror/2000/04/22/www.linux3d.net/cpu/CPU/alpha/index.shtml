<html>

<head>
<title>Alpha- CPU Gurus</title>
<style TYPE="text/css" TITLE="not underlined links">

A {text-decoration: none}

</style>
</head>

<body bgcolor="#000000" text="#000000" link="#EF7300" vlink="#EF7300" alink="#EF7300">

<p>&nbsp;</p>
<div align="center"><center>

<table border="0" cellpadding="0" cellspacing="0" width="730" bgcolor="#EF9C00">
  <tr>
    <td colspan="3" width="730" bgcolor="#EF9C00"><html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Top Logo</title>
<meta name="GENERATOR" content="Microsoft FrontPage 3.0">
</head>

<body topmargin="0" leftmargin="0">

<p><!--webbot bot="ImageMap" rectangle=" (198,1) (727, 69)  http://www.linux3d.net/cpu"
rectangle=" (1,0) (154, 69)  http://www.linux3d.net"
src="http://www.linux3d.net/cpu/image/cglogo2.gif" width="730" height="70" border="0" startspan --><MAP NAME="FrontPageMap"><AREA SHAPE="RECT" COORDS="198, 1, 727, 69" HREF="http://www.linux3d.net/cpu"><AREA SHAPE="RECT" COORDS="1, 0, 154, 69" HREF="../../../index.html"></MAP><a href="../../_vti_bin/shtml.exe/cpu/menus/toplogo.html/map"><img src="http://www.linux3d.net/cpu/image/cglogo2.gif" width="730" height="70" border="0" ismap usemap="#FrontPageMap"></a><!--webbot bot="ImageMap" endspan i-checksum="16510" --></p>
</body>
</html>
</td>
  </tr>
  <tr>
    <td colspan="3" width="730" bgcolor="#000000"></td>
  </tr>
  <tr>
    <td colspan="3" width="730" bgcolor="#EF7300"><p align="center"><strong><font face="Arial"
    size="2">- The microprocessor architects -</font></strong></td>
  </tr>
  <tr>
    <td colspan="3" width="730" bgcolor="#000000"></td>
  </tr>
  <tr>
    <td width="160" bgcolor="#EF9C00" valign="top" align="left"><img
    src="../../../images/dott.gif" width="160" height="1"><div align="center"><center><table
    border="0" cellpadding="3" cellspacing="0" width="92">
      <tr>
        <td colspan="3" width="87"><img src="../../../images/dott.gif" width="140" height="1"></td>
      </tr>
      <tr>
        <td width="4"><img src="../../../images/dott.gif" width="1" height="1"></td>
        <td width="20" bgcolor="#000000"><img src="../../image/menu.gif" width="134" height="15"><table border="0"
        cellspacing="0" width="136">
          <tr>
            <td bgcolor="#EF7300"><html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Left menu - sections</title>
<style TYPE="text/css" TITLE="not underlined links">

A {text-decoration: none}

</style>
</head>

<body topmargin="0" leftmargin="0">

<table border="0" cellpadding="2" cellspacing="0" width="100%">
  <tr>
    <td width="100%"><font face="Arial" size="2" color="#000000"><strong>[CPUs]</strong></font><font
    face="Arial" size="1"><br>
    </font><font face="Arial" size="2">- IA64<br>
    - <a href="http://www.linux3d.net/cpu/CPU/epic/" style="color: rgb(0,0,0)">EPIC</a> </font><font
    face="Arial" size="1" color="#FFFFFF">working</font><font face="Arial" size="2"><br>
    - <a href="http://www.linux3d.net/cpu/CPU/x86/index.shtml" style="color: rgb(0,0,0)">x86</a>
    </font><font face="Arial" size="1" color="#FFFFFF">working</font><font face="Arial"
    size="2"><br>
    - E2k<br>
    - post-EPIC<br>
    - <a href="index.shtml" style="color: rgb(0,0,0)">Alpha</a>
    </font><font face="Arial" size="1" color="#FFFFFF">working</font><p><font face="Arial"
    size="2" color="#000000"><strong>[Articles]<br>
    </strong><a style="color: rgb(0,0,0)"
    href="http://www.linux3d.net/cpu/articles/index.shtml">- Index</a> </font><font
    face="Arial" size="1" color="#FFFFFF">working</font></p>
    <p><font face="Arial" size="2" color="#000000"><strong>[Resources]<br>
    - Web -<br>
    - </strong><a href="http://www.linux3d.net/cpu/resources/other/" style="color: rgb(0,0,0)">Worthy
    links</a><strong> </strong></font><font face="Arial" size="1" color="#FFFFFF">working</font><font
    face="Arial" size="2" color="#000000"><strong><br>
    </strong></font><font face="Arial" size="2">- IA64<br>
    - <a style="color: rgb(0,0,0)" href="http://www.linux3d.net/cpu/resources/epic/">EPIC</a> </font><font
    face="Arial" size="1" color="#FFFFFF">working</font><font face="Arial" size="2"><br>
    - <a style="color: rgb(0,0,0)" href="http://www.linux3d.net/cpu/resources/x86/">x86</a> </font><font
    face="Arial" size="1" color="#FFFFFF">working</font><font face="Arial" size="2"><br>
    - <a href="http://www.linux3d.net/cpu/resources/e2k/" style="color: rgb(0,0,0)">E2k</a> </font><font
    face="Arial" size="1" color="#FFFFFF">working</font><font face="Arial" size="2"><br>
    - post-EPIC<br>
    <strong>- On site -<br>
    </strong>- <a
    href="http://www.3dnow.org/cgi-bin/forums/forumdisplay.cgi?action=topics&amp;forum=CPU+Gurus+@+Linux3D.Net&amp;number=15"
    style="color: rgb(0,0,0)">Discussion board</a><br>
    </font><font face="Arial" size="1" color="#FFFFFF">working</font></p>
    <p><font face="Arial" size="2" color="#000000"><strong>[Contacts]<br>
    </strong>- <a href="http://www.linux3d.net/cpu/author.shtml" style="color: rgb(0,0,0)">Author</a>
    &nbsp; </font><font face="Arial" size="1" color="#FFFFFF">working</font><font face="Arial"
    size="2" color="#000000"><br>
    - Comments</font></p>
    <p><a href="http://www.linux3d.net/cpu" style="color: rgb(0,0,0)"><font face="Arial"
    size="2" color="#000000"><strong>Back to Main menu</strong></font></a></td>
  </tr>
</table>
</body>
</html>
</td>
          </tr>
        </table>
        </td>
        <td width="27"><img src="../../../images/dott.gif" width="1" height="1"></td>
      </tr>
      <tr>
        <td width="51" colspan="3"><img src="../../../images/dott.gif" width="140" height="1"></td>
      </tr>
    </table>
    </center></div></td>
    <td width="859" valign="top" align="left" bgcolor="#FFFFFF" rowspan="2"><img
    src="../../../images/dott.gif" width="568" height="1"><table border="0" cellspacing="0"
    width="100%" cellpadding="2">
      <tr>
        <td width="100%" colspan="2"><font face="Arial" size="4">Future of Alpha architecture</font></td>
      </tr>
      <tr>
        <td width="38%"><font face="Arial" size="2"><a
        href="#Ability to exploit various parallelism">Ability to exploit various parallelism</a><br>
        <a href="#Efficiency of instruction set">Efficiency of instruction set</a><br>
        <a href="#Floating-point performance">Floating-point performance</a><br>
        I<a href="#Integer performance">nteger performance</a><br>
        <a href="#Multimedia performance">Multimedia performance</a><br>
        <a href="#Micro-architecture">Micro-architecture</a><br>
        </font></td>
        <td width="62%" valign="top" align="left"><font face="Arial" size="2"><a
        href="#Logic, circuit design and layout">Logic, circuit design and layout</a><br>
        <a href="#Process technology">Process technology</a><br>
        <a href="#Compiler quality">Compiler quality</a><br>
        <a href="#Applications">Applications</a><br>
        <a href="#Conclusion">Conclusion</a></font></td>
      </tr>
    </table>
    <p>&nbsp;</p>
    <table border="0" cellpadding="2" cellspacing="0" width="100%">
      <tr>
        <td width="100%"><font face="Arial" size="2">Alpha architecture is still kings in
        performance. Let we look how about his future. Overall performance of architecture is
        determined by following components:<br>
        <br>
        - Ability to exploit various parallelism<br>
        - Efficiency of instruction set<br>
        - Micro-architecture<br>
        - Logic, circuit design and layout<br>
        - Process technology<br>
        - Compiler quality<br>
        - Applications<br>
        <br>
        Let we look close to various component of overall architecture performance, and what we
        can expect in near future.<br>
        <br>
        <br>
        <a name="Ability to exploit various parallelism"><strong>Ability to exploit various
        parallelism</strong></a><br>
        <br>
        Today Alpha architecture not contains special support for extracting more explicit or
        speculative parallelism than traditional out-of-order execution. Instruction set does not
        contain instructions, which could direct to hardware information allowing exploiting more
        parallelism.<br>
        &nbsp;&nbsp;&nbsp; Seems more likely, that Alpha 21464 will focus more on exploiting more
        performance by multi-threaded design. Instead switching thread on L2, (L1) , TLB miss,
        instructions from threads will be scheduled to execution from common reorder buffer,
        improving by this way resources utilization also in case when is not sufficient
        parallelism in one thread to efficiently utilize resources. By this way, 8-issue Alpha can
        still extract enough parallelism for gaining performance. Focus on more throughout
        oriented performance, than single-thread performance may be beneficial for servers, but
        less for today's application. Never mind scalability issue. Just look into for example
        Microsoft SQL server scalability. Here should be said that single-thread performance
        should be not given as victim of throughput. If single-thread CPU throughput is 1, 2
        thread has throughput 1.2 (equally both threads run on 60% speed as in single-thread
        implementation, assuming totally independent threads), then in most cases single-thread
        CPU should be preferred. Note that 4 2-threads CPU from scalability point of view are
        8-CPU system. If theoretical performance in our case of 4 1-thread CPU is 4 and 2-thread
        CPUs is 4.8, real performance getting into count scalability will be less that performance
        of 4 single-issue CPUs. Multi-threaded CPU is obviously advantage in case, that
        single-thread performance is not significantly penalized. However, CPU performance is
        going up in faster pace that memory latency reduction, thus for high GHz and/or wide-issue
        implementation advantage of multi-threading will be higher, delivering expected gains.<br>
        IN MY VIEW, MULTITHREADING SHOULD BE USED ONLY WHEN TECHNIQUES FOR SINGLE-THREAD
        PERFORMANCE IMPROVEMENTS ARE EXHAUSTED. BUT TODAY, STILL EXISTS TECHNIQUES, WHICH CAN GET
        ADVANTAGE OF WIDER-ISSUE IMPLEMENTATIONS TO BOOST SINGLE-THREAD PERFORMANCE.<br>
        <br>
        <br>
        <a name="Efficiency of instruction set"><strong>Efficiency of instruction set</strong></a><br>
        <br>
        Here we will more in detail look into Alpha instruction set architecture and its effect on
        future evolution of Alpha architecture.<br>
        <br>
        <br>
        <a name="Floating-point performance"><strong>Floating-point performance</strong></a><br>
        <br>
        One of very positive aspect of Alpha instruction set is that create very orthogonal
        instruction set with respect of instruction interdependencies. There is not shared flag
        register for conditional branches and instructions dependent on flags. There also not
        shared accumulator or multiply-result register, like in other RISC architectures. Relaxing
        memory ordering was one of key advantage of Alpha architecture, mainly for in-order
        execution implementations. However, Alpha architecture instruction set, in today form
        contains some limitations.<br>
        <br>
        Floating-point performance of Alpha architecture today is good, thanks to very
        high-frequency implementations and enough registers (but same number of register we can
        find in some other RISC architectures). Floating-point intensive applications allow
        typically exploit much more parallelism that in integer intensive applications. One of key
        drawback of Alpha architecture is missing support for high-performance floating-point
        implementations. Mostly is meaning floating-point multiply-add, floating-point
        multiply-subtract and operations on packed floating-point operands.<br>
        With today 4 issue Alpha implementations containing one floating-point multiplier and one
        floating-point adder, peak performance is 2 Flops/tick. When we expect in near future 1
        GHz implementations, this is translated into 2 Gflops peak performance. This number is not
        impressive in comparison to Sony Emotion Engine with peak 6 Gflops at 300 MHz. In
        comparison with 6.4 Gflops peak single-precision floating-point performance of Merced at
        800 MHz, is 2 Gflops not very impressive. Even that real performance is different from
        peak however, still is more than likely, that Alpha (meaning 21264 and 21364) will lose
        leading role.<br>
        Extending Alpha instruction set with support at least packed floating-point operations
        will allow at least close performance gap. From my point of view, lack of fused
        multiply-add/subtract has following impact. Typically, fused multiply-add/subtract latency
        is smaller that latency of separate operations, especially when is saved one rounding.
        However, by proper design of reorder-buffer scheduling mechanism is possible to get
        advantage of fused operation. Modification is pretty straightforward. Reorder-buffer
        receiving register numbers, for which will be result computed in next tick in arithmetic
        unit. By sending this couple tick earlier, then result is computed (note that FP
        operations are multi-cycle on Alpha and other architectures), allow to select subsequent
        FP add operation earlier, allowing to fuse back-to-back FP add operation with FP multiply
        in-progress. At least latency can be improved.<br>
        Another issue is throughput. To keep pace with fast development of other architectures,
        especially for keeping pace in floating-point intensive applications, more than 4-issue
        implementations of Alpha are imperative. Next is required 8-issue implementation. However,
        if Alpha instruction set will be designed with support of fused multiply-add/subtract,
        still 4-issue implementation will be enough - 2 fused multiply-add/subtract + memory +
        memory/integer.<br>
        &nbsp;&nbsp;&nbsp; Requiring more and more FP performance will produce problems with
        issue-width with number of FP write ports. For architecture with 4 fused
        multiply-add/subtract is needed 4 register write ports and 4 issued instructions, while
        Alpha needed 8 write ports and 8 issued instructions. <br>
        &nbsp;&nbsp;&nbsp; Adding fused multiply-add/subtract to Alpha architecture will not easy.
        Mostly, because there is not too much left op-code space for introduction additional
        register operand and additional op-codes. Relative useful solution would be creating R[rd]
        = R[rd] + R[ra] * R[rb] or R[rd'] = R[rd] + R[ra] * R[rb], where rd' is derived from rd.
        It is not as efficient as R[rd] = R[rc] + R[ra] * R[rb], but performance gain is
        relatively good.<br>
        &nbsp;&nbsp;&nbsp; Another issue about FP performance is number of FP registers. While it
        is not critical issue, for 2 multiply and add/subtract per tick architecture for 4
        multiply and add/subtract is playing more important role and beyond is larger FP register
        set (I am talking about architectural, not physical registers) more than required.<br>
        &nbsp;&nbsp;&nbsp; Also important issue is load/store bandwidth. One way is just adding
        additional load/store unit and appropriate cache ports, but it is very expensive solution.
        Supporting wider load/store operation (on packed aligned 32 or 64-bit FP quantities) is
        less expensive way and saves also instruction issue bandwidth. I fully understand, that
        register-renaming logic will be significantly more complicated when 2 destination
        registers are written, because in theory it would require 2x more write ports to register
        rename structure per instruction. However, with some restrictions it is possible to reduce
        complexity to manageable level.<br>
        &nbsp;&nbsp;&nbsp; Question about support of 128-bit packed floating-point data types
        remain. While it solves more issue at once - improved instruction issue width, increases
        register file capacity, improves load/store throughput, it requires substantially more
        resources, but mainly a lot of new instructions, or modified semantic of existing
        instructions.<br>
        &nbsp;&nbsp;&nbsp; One of fundamental issue, in further improving FP performance, what is
        missing now in Alpha (but is also missing in IA-64, but is included in E2k) is hardware
        support compiler controlled prefetching. However, this hardware and related instruction
        set extensions could be included in Alpha instruction set architecture in future.<br>
        <br>
        Conclusion is, that Alpha instruction set should be extended with earlier mentioned
        instructions, otherwise will be under-performer in not as far future, as one may think.<br>
        <br>
        <br>
        <a name="Integer performance"><strong>Integer performance</strong></a><br>
        <br>
        Improving integer performance is one of tougher task in comparison to improving
        floating-point and multimedia performance.<br>
        First way of improving performance is reduce various penalties. Reducing branch penalty is
        very important. There will be helpful other techniques, in addition to very effective
        branch prediction mechanism included in Alpha 21264 for reducing branch penalties. One of
        obvious candidates is predicated instruction execution. Alpha supports only conditional
        move to reduce branch penalty. Still remain memory operations and subprogram calls, for
        which conditional move only is not adequate. However, sophisticated compiler can play
        tricks with using move conditional to change base address of load/store instruction to
        simulate predicated execution. It will work in way, that if load/store should be
        suppressed, move conditional will move to base register of load/store instruction address
        of dummy memory area, used for this purpose. However, increased number of instructions and
        memory resources is penalty. One of way can be adding guarding instruction, which contains
        register-based condition, which will be used in subsequent instruction(s). This
        instruction just adds tag into micro-operation stored into reorder buffer.<br>
        In many cases, counted loops with more than few iteration can be handled with 100% branch
        prediction rate using immediate operand merging technique (see future of x86 architecture
        articles).<br>
        Next issue is branch prepare instruction. Sometimes branch is hard predictable even by
        dynamic branch prediction. In that case, branch prepare instruction allow reduce branch
        penalty.<br>
        <br>
        Another issue is then memory latency. When load waits to resolve cache miss, all
        subsequent operations cannot retire, flooding reorder buffer. Even big Alpha's reorder
        buffer will be full in case of L2 cache miss. By extending instruction set architecture by
        load instruction, which allow &quot;early retirement&quot; is opened way for better
        dealing with memory latency.<br>
        &nbsp;&nbsp;&nbsp; One of drawback of Alpha instruction set is that memory operation does
        not contain information about locality. Including information about locality has two
        effects. First, L1 cache miss latency is improved knowing that will be L1 miss and early
        start L2 cache access. Second, cache hit ratio could be improved. Also Alpha memory
        instructions does not contain field, which can direct prefetch hint. Really positive on
        Alpha 21364 is dealing with memory latency by integrating L2 cache on chip and reducing
        memory latency of memory subsystem by integrating memory controller.<br>
        <br>
        <br>
        <a name="Multimedia performance"><strong>Multimedia performance</strong></a><br>
        <br>
        Alpha concept of simple and fast instruction set architecture results in relative simple
        MVI instruction set extension. Even that for many multimedia related tasks require more
        processor cycles that Pentium-III, faster clock in many cases compensates penalty. But
        because seems, that frequency disparity between Alpha and next generation x86 architecture
        will be narrower, it is more likely that additional multimedia acceleration will be
        required, to keep pace with rest of architectures. It should not negatively affect
        frequency, however. Packed multiply is one of urgent candidate for inclusion in
        instruction set. It is multi-cycle operation, which does not create critical path.
        Different question is saturated arithmetic. Most likely, addition/subtraction with
        saturation, for high frequency implementation, should be broken into two cycles. For
        maximizing performance, packed multiply scaled-add/subtract instruction will allow defend
        performance against first implementations of IA-64 architecture.<br>
        <br>
        <br>
        <a name="Micro-architecture"><strong>Micro-architecture</strong></a><br>
        <br>
        From architecture point of view, can be applied many of techniques described for x86
        architecture. For unleashing more parallelism, it is needed to reduce length of dependency
        chains and broke long instruction dependency chains. Immediate operand merging described
        for x86 architecture is very important. Transforming on-the-fly move conditional based
        code into predicated could significantly reduce dependency chains. Using stack caching in
        registers as described in article about x86 can unleash more parallelism across subprogram
        call boundaries, by reducing store-load from critical path.<br>
        &nbsp;&nbsp;&nbsp; Because instruction set architecture is lacking support for efficient
        Boolean expression trees high reduction, doing this type of transformation on the fly by
        hardware will be costly, but more that welcomed.<br>
        &nbsp;&nbsp;&nbsp; I think, that even 8-issue architecture implementation will be very
        complex, but using code-transformation techniques could be extracted reasonable
        performance gains. Two threads per CPU support could be some insurance for the case, that
        code transformation techniques, compilers and applications will not live up to expectation
        for this wide architecture implementation.<br>
        &nbsp;&nbsp;&nbsp; From my point of view, it is unlikely, that Alpha architecture should
        be effectively scaled beyond 8-issue implementations. However, performance of 8-issue
        implementation could be dramatically boosted by instruction set extensions, rather that
        going for wider implementation.<br>
        &nbsp;&nbsp;&nbsp; Another very interesting approach could be chosen in combination with
        multi-threading - creating ultra pipelined high-frequency implementation. While
        single-thread performance will be not dramatically penalized, throughput could be
        increased dramatically. However, logic, circuit design, layout and other engineering
        factor makes this task extremely uneasy.<br>
        <br>
        <br>
        <a name="Logic, circuit design and layout"><strong>Logic, circuit design and layout</strong></a><br>
        <br>
        Still to nowadays Alpha products was known for excellent logic, circuit design and layout.
        While still assumed that high quality for in this are will remain, there is more likely
        that designers of IA-64 and other architectures will soon step-by-step reduce this gap.<br>
        <br>
        <br>
        <a name="Process technology"><strong>Process technology</strong></a><br>
        <br>
        Process technology is very important. It is hard to overcome process gap in architecture.
        To stay in leading position, Alpha should be produced at least at similar or better
        process that other near future architectures.<br>
        <br>
        <br>
        <a name="Compiler quality"><strong>Compiler quality</strong></a><br>
        <br>
        Alpha system architecture was also known for good compilers. However, with huge investment
        in compilers technology induced by IA-64 architecture and overall shift to more
        sophisticated compiler technology could eliminate any Alpha system architecture advantage.<br>
        <br>
        <br>
        <a name="Applications"><strong>Applications</strong></a><br>
        <br>
        Applications are evolving very fast. From application level, Alpha architecture does not
        contain magic bullet, which allow speedup applications in new way. With migrating of other
        architectures to 64-bit addressing, it is unlikely that Alpha can gain application
        performance in other way, that other today architectures.<br>
        <br>
        <br>
        <a name="Conclusion"><strong>Conclusion</strong></a><br>
        <br>
        While today from pure from technical (not from business) point of view Alpha architecture
        is really state of art and leading architecture, in short future, overall architecture
        should be revisited to keep pace with other architectures development, because otherwise
        can easily loss ground. From longer perspective, in about 10 years, it is more likely,
        that Alpha architecture (based on today instruction set decisions) will shading. This does
        not mean, however, that Alpha team is not able to bring new concept and then consequently
        new instruction set and architecture.</font><p>&nbsp;</p>
        <p>&nbsp;</p>
        <p>&nbsp;</p>
        <p>&nbsp;</p>
        <p>&nbsp;</td>
      </tr>
      <tr>
        <td width="100%" bgcolor="#EF7300"><p align="center"><font face="Arial" size="2"
        color="#000000">Site design by <a href="mailto:kornel@linux3d.net"
        style="color: rgb(255,255,255)">Kornel Kiss</a> - ©1999<strong> </strong><a
        href="../../menus/copyright.shtml" style="color: rgb(255,255,255)">Copyright</a> ©1999
        Linux3D.net &amp; CPU Gurus</font></td>
      </tr>
    </table>
    </td>
    <td width="3" bgcolor="#EF9C00" rowspan="2"><img src="../../../images/dott.gif" width="3"
    height="1"></td>
  </tr>
  <tr>
    <td width="160" bgcolor="#EF9C00" valign="top" align="left">&nbsp;<p align="center">&nbsp;</p>
    <p align="center">&nbsp;</p>
    <p align="center">&nbsp;</p>
    <p align="center">&nbsp;</p>
    <p align="center">&nbsp;</p>
    <p align="center">&nbsp;</td>
  </tr>
  <tr>
    <td colspan="3" width="730" bgcolor="#EF9C00"><img src="../../../images/dott.gif"
    width="730" height="3"></td>
  </tr>
</table>
</center></div>
</body>
</html>
